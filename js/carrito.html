const STORAGE_CART_KEY = 'sim_carrito_v1';

let carrito = loadCartFromStorage(); // array de { productId, qty }

/* ---------- Persistencia ---------- */
function loadCartFromStorage() {
  try {
    const raw = localStorage.getItem(STORAGE_CART_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    console.error('Error leyendo carrito de storage', e);
    return [];
  }
}
function saveCartToStorage() {
  localStorage.setItem(STORAGE_CART_KEY, JSON.stringify(carrito));
}

/* ---------- Acciones sobre el carrito ---------- */
function agregarAlCarrito(productId, cantidad = 1) {
  productId = Number(productId);
  const idx = carrito.findIndex(i => Number(i.productId) === productId);
  if (idx >= 0) {
    carrito[idx].qty += cantidad;
  } else {
    carrito.push({ productId, qty: cantidad });
  }
  saveCartToStorage();
  renderCarrito(); // llamar al render (definido en script.js)
}

function actualizarCantidad(productId, qty) {
  productId = Number(productId);
  qty = Number(qty);
  if (Number.isNaN(qty) || qty < 1) qty = 1;
  const idx = carrito.findIndex(i => Number(i.productId) === productId);
  if (idx >= 0) {
    carrito[idx].qty = qty;
  }
  carrito = carrito.filter(i => i.qty > 0);
  saveCartToStorage();
  renderCarrito();
}

function eliminarDelCarrito(productId) {
  productId = Number(productId);
  carrito = carrito.filter(i => Number(i.productId) !== productId);
  saveCartToStorage();
  renderCarrito();
}

function vaciarCarrito() {
  carrito = [];
  saveCartToStorage();
  renderCarrito();
}

/* ---------- Helpers para UI ---------- */
function obtenerItemsDelCarritoConProducto() {
  // Devuelve array de { product, qty, subtotal }
  return carrito.map(item => {
    const producto = productos.find(p => Number(p.id) === Number(item.productId));
    return {
      product: producto,
      qty: item.qty,
      subtotal: producto ? producto.precio * item.qty : 0
    };
  }).filter(x => x.product); // elimina si producto no existe
}

function calcularTotalCarrito() {
  return obtenerItemsDelCarritoConProducto().reduce((acc, cur) => acc + cur.subtotal, 0);
}
